## ä¹ã€æ’ä»¶ç³»ç»Ÿ - ä¸­è½¬ç«™ä½™é¢æŸ¥è¯¢

> **è®¾è®¡åŸåˆ™**: ä¸€ä¸ªä¸­è½¬ç«™ = ä¸€ä¸ªæ’ä»¶ï¼Œé¿å…å•æ’ä»¶æ”¯æŒå¤šç«™çš„ç»´æŠ¤åœ°ç‹±

### 9.1 ç³»ç»Ÿæ¶æ„

```
Rust ä¸»ç¨‹åº
 â”œâ”€ æ’ä»¶ç®¡ç†å™¨ï¼ˆåŠ è½½ / å¸è½½ / çƒ­é‡è½½ï¼‰
 â”œâ”€ å¹¶å‘è°ƒåº¦å™¨ï¼ˆå¤šä¸­è½¬ç«™å¹¶è¡ŒæŸ¥è¯¢ï¼‰
 â”œâ”€ ç»Ÿä¸€æ•°æ®ç»“æ„ï¼ˆBalanceResultï¼‰
 â”œâ”€ ç¼“å­˜å±‚ / é™æµå™¨ / é‡è¯•æœºåˆ¶
 â””â”€ JS Runtime æ²™ç›’ï¼ˆQuickJS / Deno / V8ï¼‰
        â””â”€ balance_xxx.jsï¼ˆä¸€ä¸ªä¸­è½¬ç«™ä¸€ä¸ªæ’ä»¶ï¼‰
```

### 9.2 æ’ä»¶ç®¡ç†å™¨ (PluginManager)

| åŠŸèƒ½ç‚¹ | æè¿° | çŠ¶æ€ |
|--------|------|------|
| æ’ä»¶çƒ­åŠ è½½ | è¿è¡Œæ—¶åŠ¨æ€åŠ è½½ JS æ’ä»¶æ–‡ä»¶ | [ ] |
| æ’ä»¶å¸è½½ | å®‰å…¨å¸è½½å¹¶é‡Šæ”¾èµ„æº | [ ] |
| æ’ä»¶çƒ­é‡è½½ | æ— éœ€é‡å¯åº”ç”¨æ›´æ–°æ’ä»¶ | [ ] |
| æ’ä»¶å‘ç° | è‡ªåŠ¨æ‰«æ `~/.claude/plugins/balance/` ç›®å½• | [ ] |
| æ’ä»¶æ ¡éªŒ | æ ¡éªŒæ’ä»¶å…ƒæ•°æ®å’Œ API å…¼å®¹æ€§ | [ ] |
| æ’ä»¶ç‰ˆæœ¬ç®¡ç† | æ”¯æŒå¤šç‰ˆæœ¬æ’ä»¶å…±å­˜ | [ ] |
| ä¾èµ–æ£€æŸ¥ | æ£€æŸ¥æ’ä»¶æ‰€éœ€çš„ Runtime ç‰ˆæœ¬ | [ ] |

### 9.3 å¹¶å‘è°ƒåº¦å™¨ (ConcurrencyScheduler)

| åŠŸèƒ½ç‚¹ | æè¿° | çŠ¶æ€ |
|--------|------|------|
| å¹¶è¡ŒæŸ¥è¯¢ | å¤šä¸­è½¬ç«™åŒæ—¶å‘èµ·æŸ¥è¯¢ | [ ] |
| ä»»åŠ¡é˜Ÿåˆ— | ç®¡ç†å¾…æ‰§è¡Œçš„æŸ¥è¯¢ä»»åŠ¡ | [ ] |
| å¹¶å‘é™åˆ¶ | å¯é…ç½®æœ€å¤§å¹¶å‘æ•° | [ ] |
| è¶…æ—¶æ§åˆ¶ | å•ä¸ªæ’ä»¶æ‰§è¡Œè¶…æ—¶è®¾ç½® | [ ] |
| ä»»åŠ¡å–æ¶ˆ | æ”¯æŒå–æ¶ˆæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ | [ ] |
| æ‰§è¡Œä¼˜å…ˆçº§ | é«˜ä¼˜å…ˆçº§æ’ä»¶ä¼˜å…ˆæ‰§è¡Œ | [ ] |

### 9.4 ç»Ÿä¸€æ•°æ®ç»“æ„ (BalanceResult)

| å­—æ®µ | ç±»å‹ | æè¿° |
|------|------|------|
| `provider` | String | ä¸­è½¬ç«™æ ‡è¯†ç¬¦ |
| `providerName` | String | ä¸­è½¬ç«™æ˜¾ç¤ºåç§° |
| `balance` | f64 | å½“å‰ä½™é¢ |
| `currency` | String | è´§å¸å•ä½ï¼ˆUSD/CNY/ç§¯åˆ†ç­‰ï¼‰|
| `quota` | f64? | æ€»é¢åº¦ï¼ˆå¯é€‰ï¼‰|
| `usedQuota` | f64? | å·²ä½¿ç”¨é¢åº¦ï¼ˆå¯é€‰ï¼‰|
| `expiresAt` | Date? | ä½™é¢è¿‡æœŸæ—¶é—´ï¼ˆå¯é€‰ï¼‰|
| `lastUpdated` | Date | æœ€åæ›´æ–°æ—¶é—´ |
| `status` | BalanceStatus | æŸ¥è¯¢çŠ¶æ€ï¼ˆsuccess/error/timeoutï¼‰|
| `errorMessage` | String? | é”™è¯¯ä¿¡æ¯ |
| `rawData` | JSON? | åŸå§‹ API å“åº”ï¼ˆè°ƒè¯•ç”¨ï¼‰|

### 9.5 ç¼“å­˜å±‚ (CacheLayer)

| åŠŸèƒ½ç‚¹ | æè¿° | çŠ¶æ€ |
|--------|------|------|
| å†…å­˜ç¼“å­˜ | LRU ç¼“å­˜æŸ¥è¯¢ç»“æœ | [ ] |
| TTL è¿‡æœŸ | å¯é…ç½®ç¼“å­˜è¿‡æœŸæ—¶é—´ | [ ] |
| å¼ºåˆ¶åˆ·æ–° | æ”¯æŒç»•è¿‡ç¼“å­˜å¼ºåˆ¶æŸ¥è¯¢ | [ ] |
| æŒä¹…åŒ–ç¼“å­˜ | å¯é€‰çš„ç£ç›˜æŒä¹…åŒ– | [ ] |
| ç¼“å­˜é¢„çƒ­ | åº”ç”¨å¯åŠ¨æ—¶é¢„åŠ è½½ | [ ] |

### 9.6 é™æµå™¨ (RateLimiter)

| åŠŸèƒ½ç‚¹ | æè¿° | çŠ¶æ€ |
|--------|------|------|
| å…¨å±€é™æµ | æ‰€æœ‰æ’ä»¶å…±äº«çš„è¯·æ±‚é™åˆ¶ | [ ] |
| æ’ä»¶çº§é™æµ | æ¯ä¸ªæ’ä»¶ç‹¬ç«‹çš„è¯·æ±‚é™åˆ¶ | [ ] |
| æ»‘åŠ¨çª—å£ | åŸºäºæ»‘åŠ¨çª—å£çš„é™æµç®—æ³• | [ ] |
| è‡ªå®šä¹‰é¢‘ç‡ | å¯é…ç½® X ç§’å†…æœ€å¤§ Y æ¬¡è¯·æ±‚ | [ ] |
| é™æµç­–ç•¥ | é˜Ÿåˆ—ç­‰å¾… / ç›´æ¥æ‹’ç» / é™çº§å¤„ç† | [ ] |
| é™æµç»Ÿè®¡ | è®°å½•è¢«é™æµçš„è¯·æ±‚æ¬¡æ•° | [ ] |

#### 9.6.1 é™æµé…ç½®ç¤ºä¾‹

```toml
[rate_limit]
global_max_requests_per_second = 10  # å…¨å±€æ¯ç§’æœ€å¤§è¯·æ±‚æ•°
per_plugin_max_requests_per_minute = 30  # å•æ’ä»¶æ¯åˆ†é’Ÿæœ€å¤§è¯·æ±‚æ•°
burst_size = 5  # çªå‘è¯·æ±‚å®¹é‡
```

### 9.7 é‡è¯•æœºåˆ¶ (RetryPolicy)

| åŠŸèƒ½ç‚¹ | æè¿° | çŠ¶æ€ |
|--------|------|------|
| è‡ªåŠ¨é‡è¯• | å¤±è´¥åè‡ªåŠ¨é‡è¯• | [ ] |
| é‡è¯•æ¬¡æ•° | å¯é…ç½®æœ€å¤§é‡è¯•æ¬¡æ•° | [ ] |
| æŒ‡æ•°é€€é¿ | æŒ‡æ•°é€’å¢çš„é‡è¯•é—´éš” | [ ] |
| é‡è¯•æ¡ä»¶ | å¯é…ç½®å“ªäº›é”™è¯¯è§¦å‘é‡è¯• | [ ] |
| ç†”æ–­å™¨ | è¿ç»­å¤±è´¥åæš‚åœè¯·æ±‚ | [ ] |

### 9.8 JS Runtime æ²™ç›’ (SandboxRuntime)

> **å®‰å…¨ç¬¬ä¸€**: æ‰€æœ‰æ’ä»¶åœ¨ä¸¥æ ¼æ²™ç›’ç¯å¢ƒä¸­æ‰§è¡Œ

| åŠŸèƒ½ç‚¹ | æè¿° | çŠ¶æ€ |
|--------|------|------|
| éš”ç¦»æ‰§è¡Œ | æ¯ä¸ªæ’ä»¶ç‹¬ç«‹çš„æ‰§è¡Œç¯å¢ƒ | [ ] |
| å†…å­˜é™åˆ¶ | é™åˆ¶å•ä¸ªæ’ä»¶å†…å­˜ä½¿ç”¨ | [ ] |
| CPU é™åˆ¶ | é™åˆ¶å•ä¸ªæ’ä»¶æ‰§è¡Œæ—¶é—´ | [ ] |
| ç½‘ç»œé™åˆ¶ | ä»…å…è®¸ HTTPS å‡ºç«™è¯·æ±‚ | [ ] |
| æ—¥å¿—æ¡¥æ¥ | æ’ä»¶ console.log è¾“å‡ºåˆ°ä¸»ç¨‹åº | [ ] |

#### 9.8.1 èƒ½åŠ›ç™½åå•ï¼ˆå…è®¸ï¼‰

| API | æè¿° |
|-----|------|
| `fetch()` | HTTP/HTTPS è¯·æ±‚ï¼ˆä»…å‡ºç«™ï¼‰|
| `console.log/warn/error` | æ—¥å¿—è¾“å‡º |
| `JSON.parse/stringify` | JSON å¤„ç† |
| `setTimeout/setInterval` | å®šæ—¶å™¨ï¼ˆæœ‰ä¸Šé™ï¼‰|
| `TextEncoder/TextDecoder` | æ–‡æœ¬ç¼–ç  |
| `crypto.subtle` | åŠ å¯†åŸè¯­ï¼ˆå¯é€‰ï¼‰|
| `atob/btoa` | Base64 ç¼–è§£ç  |

#### 9.8.2 èƒ½åŠ›é»‘åå•ï¼ˆç¦æ­¢ï¼‰

| API | æè¿° | é£é™© |
|-----|------|------|
| âŒ `require('fs')` | æ–‡ä»¶ç³»ç»Ÿè®¿é—® | æ•°æ®æ³„éœ² |
| âŒ `require('child_process')` | å­è¿›ç¨‹æ‰§è¡Œ | ä»»æ„ä»£ç æ‰§è¡Œ |
| âŒ `require('net')` | åŸå§‹ç½‘ç»œå¥—æ¥å­— | å†…ç½‘æ¸—é€ |
| âŒ `require('os')` | æ“ä½œç³»ç»Ÿä¿¡æ¯ | ä¿¡æ¯æ³„éœ² |
| âŒ `eval()` | åŠ¨æ€ä»£ç æ‰§è¡Œ | ä»£ç æ³¨å…¥ |
| âŒ `Function()` | åŠ¨æ€åˆ›å»ºå‡½æ•° | ä»£ç æ³¨å…¥ |
| âŒ `WebSocket` | WebSocket è¿æ¥ | æŒä¹…è¿æ¥é£é™© |
| âŒ `importScripts` | åŠ¨æ€åŠ è½½è„šæœ¬ | è¿œç¨‹ä»£ç æ‰§è¡Œ |

#### 9.8.3 Rust å®ç°ç»†èŠ‚ - rquickjs Crate

> **æŠ€æœ¯é€‰å‹**: `rquickjs` - Rust ä¸ QuickJS çš„é«˜æ€§èƒ½ç»‘å®šï¼Œæ”¯æŒ async/await

##### ä¾èµ–é…ç½® (Cargo.toml)

```toml
[dependencies]
# QuickJS Runtime
# âš ï¸ æ³¨æ„ï¼šä¸å¯ç”¨ "allocator" feature ä»¥ä¿è¯ set_memory_limit ç”Ÿæ•ˆ
rquickjs = { version = "0.6", features = [
    "bindgen",      # è‡ªåŠ¨ç”Ÿæˆ FFI ç»‘å®š
    "classes",      # æ”¯æŒ ES6 class
    "loader",       # æ¨¡å—åŠ è½½å™¨
    "futures",      # async/await æ”¯æŒ
    "parallel",     # å¤šçº¿ç¨‹ Runtime
] }

# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1", features = ["rt-multi-thread", "sync", "time", "macros"] }

# HTTP å®¢æˆ·ç«¯ï¼ˆä¸º JS fetch æä¾›åç«¯ï¼‰
reqwest = { version = "0.12", features = ["json", "rustls-tls"], default-features = false }

# é™æµ
governor = "0.6"

# ç¼“å­˜
moka = { version = "0.12", features = ["future"] }

# åºåˆ—åŒ–
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# æ—¶é—´å¤„ç†
chrono = { version = "0.4", features = ["serde"] }

# æ—¥å¿—
tracing = "0.1"
```

##### æ ¸å¿ƒç»“æ„ä½“å®šä¹‰

```rust
use rquickjs::{AsyncContext, AsyncRuntime, Object, Value, Function, Ctx, Result as JsResult};
use std::sync::Arc;
use tokio::sync::RwLock;

/// æ’ä»¶å…ƒæ•°æ®ï¼ˆä» JS è§£æï¼‰
/// ä½¿ç”¨ camelCase ä¸ JS ä¾§å‘½åä¿æŒä¸€è‡´
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PluginMetadata {
    pub id: String,
    pub name: String,
    pub version: String,
    pub api_version: String,
    #[serde(default)]
    pub author: Option<String>,
    #[serde(default)]
    pub description: Option<String>,
    #[serde(default)]
    pub config_schema: Option<serde_json::Value>,
}

/// ä½™é¢æŸ¥è¯¢ç»“æœï¼ˆä¸»ç¨‹åºå¡«å……å­—æ®µ + æ’ä»¶è¿”å›å­—æ®µï¼‰
/// ä½¿ç”¨ camelCase ä¸ JS ä¾§å‘½åä¿æŒä¸€è‡´
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct BalanceResult {
    // ä»¥ä¸‹å­—æ®µç”±ä¸»ç¨‹åºå¡«å……
    pub provider: String,
    pub provider_name: String,
    pub last_updated: chrono::DateTime<chrono::Utc>,
    pub status: BalanceStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
    
    // ä»¥ä¸‹å­—æ®µç”±æ’ä»¶è¿”å›
    #[serde(default)]
    pub balance: f64,
    #[serde(default)]
    pub currency: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quota: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub used_quota: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub raw_data: Option<serde_json::Value>,
}

/// æ’ä»¶è¿”å›çš„åŸå§‹ä½™é¢æ•°æ®ï¼ˆä¸ JS queryBalance è¿”å›å€¼å¯¹åº”ï¼‰
#[derive(Debug, Clone, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PluginBalanceResponse {
    pub balance: f64,
    pub currency: String,
    #[serde(default)]
    pub quota: Option<f64>,
    #[serde(default)]
    pub used_quota: Option<f64>,
    #[serde(default)]
    pub expires_at: Option<String>,
    #[serde(default)]
    pub raw_data: Option<serde_json::Value>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum BalanceStatus {
    Success,
    Error,
    Timeout,
}

/// æ’ä»¶è¿è¡Œæ—¶é…ç½®
#[derive(Debug, Clone)]
pub struct PluginRuntimeConfig {
    /// å•ä¸ªæ’ä»¶æœ€å¤§å†…å­˜ (bytes)
    pub max_memory: usize,
    /// å•æ¬¡æ‰§è¡Œè¶…æ—¶ (ms)
    pub timeout_ms: u64,
    /// æœ€å¤§å¹¶å‘è¯·æ±‚æ•°
    pub max_concurrent_requests: usize,
    /// interrupt handler æ£€æŸ¥é—´éš”
    pub interrupt_check_interval_ms: u64,
}

impl Default for PluginRuntimeConfig {
    fn default() -> Self {
        Self {
            max_memory: 16 * 1024 * 1024,  // 16MB
            timeout_ms: 30_000,             // 30ç§’
            max_concurrent_requests: 10,
            interrupt_check_interval_ms: 100,  // æ¯ 100ms æ£€æŸ¥ä¸€æ¬¡ä¸­æ–­
        }
    }
}

/// æ’ä»¶é”™è¯¯ç±»å‹ï¼ˆä¸ JS ä¾§ ErrorTypes å¯¹åº”ï¼‰
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum PluginErrorType {
    NetworkError,
    AuthError,
    RateLimit,
    Timeout,
    ParseError,
    ProviderError,
    SandboxLimit,
    Unknown,
}

/// ç»“æ„åŒ–æ’ä»¶é”™è¯¯
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PluginError {
    pub error_type: PluginErrorType,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<serde_json::Value>,
}

impl std::fmt::Display for PluginError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{:?}] {}", self.error_type, self.message)
    }
}

impl std::error::Error for PluginError {}
```

##### æ²™ç›’ Runtime åˆå§‹åŒ–

```rust
use rquickjs::{AsyncRuntime, AsyncContext, Module};
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Instant;

/// åˆ›å»ºå®‰å…¨çš„æ²™ç›’ Runtimeï¼ˆå¸¦ CPU ä¸­æ–­èƒ½åŠ›ï¼‰
/// âœ… é€šè¿‡ cancel_flag + watchdog å®ç°å¯æŠ¢å è¶…æ—¶
pub async fn create_sandbox_runtime(
    config: &PluginRuntimeConfig,
    cancel_flag: Arc<AtomicBool>,
) -> JsResult<AsyncRuntime> {
    let runtime = AsyncRuntime::new()?;
    
    // è®¾ç½®å†…å­˜é™åˆ¶ï¼ˆâš ï¸ éœ€ç¡®ä¿æœªå¯ç”¨ allocator featureï¼‰
    runtime.set_memory_limit(config.max_memory).await;
    
    // è®¾ç½®æœ€å¤§æ ˆå¤§å°ï¼ˆé˜²æ­¢æ ˆæº¢å‡ºæ”»å‡»ï¼‰
    runtime.set_max_stack_size(512 * 1024).await;  // 512KB
    
    // è®¾ç½® GC é˜ˆå€¼
    runtime.set_gc_threshold(config.max_memory / 2).await;
    
    // ğŸ”’ è®¾ç½®ä¸­æ–­å¤„ç†å™¨ï¼ˆå®ç° CPU é™åˆ¶ï¼Œå¯æŠ¢å æ­»å¾ªç¯ï¼‰
    // æ¯æ¬¡ JS æ‰§è¡ŒæŒ‡ä»¤æ—¶éƒ½ä¼šè°ƒç”¨æ­¤ handler æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸­æ–­
    let cancel_flag_clone = cancel_flag.clone();
    runtime.set_interrupt_handler(Some(Box::new(move || {
        // æ£€æŸ¥æ˜¯å¦å¤–éƒ¨å–æ¶ˆï¼ˆç”± watchdog æˆ–æ‰‹åŠ¨è®¾ç½®ï¼‰
        cancel_flag_clone.load(Ordering::Relaxed)
    }))).await;
    
    Ok(runtime)
}

/// å¯åŠ¨ watchdog ä»»åŠ¡ï¼ˆåœ¨è°ƒç”¨ query_balance æ—¶ä½¿ç”¨ï¼‰
/// ç‹¬ç«‹äºä¸»æ‰§è¡Œä»»åŠ¡ï¼Œå³ä½¿ JS é˜»å¡ä¹Ÿèƒ½è§¦å‘è¶…æ—¶
fn start_watchdog(
    cancel_flag: Arc<AtomicBool>,
    timeout_ms: u64,
) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        tokio::time::sleep(tokio::time::Duration::from_millis(timeout_ms)).await;
        // è¶…æ—¶åè®¾ç½®å–æ¶ˆæ ‡å¿—ï¼Œinterrupt handler ä¼šåœ¨ä¸‹æ¬¡æ£€æŸ¥æ—¶è§¦å‘ä¸­æ–­
        cancel_flag.store(true, Ordering::Relaxed);
    })
}

/// åˆ›å»ºæ²™ç›’ Context å¹¶æ³¨å…¥å®‰å…¨ API
pub async fn create_sandbox_context(
    runtime: &AsyncRuntime,
    http_client: Arc<reqwest::Client>,
    plugin_cache: Arc<BalanceCache>,
) -> JsResult<AsyncContext> {
    // âœ… ä¿®æ­£ï¼šAsyncContext::full æ¥å— &AsyncRuntime
    let context = AsyncContext::full(runtime).await?;
    
    // æ³¨å…¥ç™½åå• API
    rquickjs::async_with!(context => |ctx| {
        inject_console_api(&ctx)?;
        inject_fetch_api(&ctx, http_client.clone())?;
        inject_text_encoding_api(&ctx)?;
        inject_base64_api(&ctx)?;
        inject_timeout_api(&ctx)?;
        inject_plugin_error_class(&ctx)?;  // æ³¨å…¥ PluginError ç±»
        
        // ğŸ”’ ç§»é™¤å±é™©å…¨å±€å¯¹è±¡
        remove_dangerous_globals(&ctx)?;
        
        Ok::<_, rquickjs::Error>(())
    }).await?;
    
    Ok(context)
}

/// æ³¨å…¥ PluginError ç±»åˆ° JS å…¨å±€
fn inject_plugin_error_class(ctx: &Ctx<'_>) -> JsResult<()> {
    // å®šä¹‰ PluginError ç±»
    ctx.eval::<(), _>(r#"
        class PluginError extends Error {
            constructor(errorType, message, details = null) {
                super(message);
                this.name = 'PluginError';
                this.errorType = errorType;
                this.details = details;
            }
            
            toJSON() {
                return {
                    errorType: this.errorType,
                    message: this.message,
                    details: this.details
                };
            }
        }
        
        // é”™è¯¯ç±»å‹å¸¸é‡
        const ErrorTypes = Object.freeze({
            NETWORK_ERROR: 'NETWORK_ERROR',
            AUTH_ERROR: 'AUTH_ERROR',
            RATE_LIMIT: 'RATE_LIMIT',
            TIMEOUT: 'TIMEOUT',
            PARSE_ERROR: 'PARSE_ERROR',
            PROVIDER_ERROR: 'PROVIDER_ERROR',
            SANDBOX_LIMIT: 'SANDBOX_LIMIT',
            UNKNOWN: 'UNKNOWN'
        });
        
        globalThis.PluginError = PluginError;
        globalThis.ErrorTypes = ErrorTypes;
    "#)?;
    
    Ok(())
}

/// ç§»é™¤å±é™©çš„å…¨å±€å¯¹è±¡
fn remove_dangerous_globals(ctx: &Ctx<'_>) -> JsResult<()> {
    let globals = ctx.globals();
    
    // åˆ é™¤å¯èƒ½è¢«æ»¥ç”¨çš„æ„é€ å‡½æ•°å’Œå¯¹è±¡
    let dangerous = [
        "eval",           // åŠ¨æ€ä»£ç æ‰§è¡Œ
        "Function",       // åŠ¨æ€åˆ›å»ºå‡½æ•°
        "WebSocket",      // æŒä¹…è¿æ¥
        "XMLHttpRequest", // æ—§å¼ HTTPï¼ˆä½¿ç”¨ fetch æ›¿ä»£ï¼‰
        "Worker",         // Web Worker
        "SharedArrayBuffer",  // å…±äº«å†…å­˜
        "Atomics",        // åŸå­æ“ä½œ
    ];
    
    for name in dangerous {
        let _ = globals.remove(name);  // å¿½ç•¥ä¸å­˜åœ¨çš„å±æ€§
    }
    
    Ok(())
}
```

##### fetch API å®ç°ï¼ˆæ ¸å¿ƒï¼‰

> **ä¿®æ­£è¦ç‚¹**ï¼šä½¿ç”¨ `Promise::new` + `ctx.spawn` + `resolve/reject.call` æ¨¡å¼

```rust
use rquickjs::{Ctx, Function, Object, Value, Promise, Class, IntoJs};
use std::sync::Arc;

/// å“åº”å¤§å°é™åˆ¶ï¼ˆé˜²æ­¢å†…å­˜è€—å°½ï¼‰
const MAX_RESPONSE_SIZE: usize = 10 * 1024 * 1024;  // 10MB

/// æ³¨å…¥å®‰å…¨çš„ fetch API
/// âœ… æ­£ç¡®æ¨¡å¼ï¼šPromise::new åˆ›å»º promise â†’ ctx.spawn æ‰§è¡Œå¼‚æ­¥ â†’ resolve/reject.call settle
fn inject_fetch_api(ctx: &Ctx<'_>, client: Arc<reqwest::Client>) -> JsResult<()> {
    let globals = ctx.globals();
    
    // æ³¨å†Œ Response ç±»
    Class::<JsResponse>::register(ctx)?;
    
    // åˆ›å»º fetch å‡½æ•°
    let client_clone = client.clone();
    globals.set("fetch", Function::new(ctx.clone(), move |ctx: Ctx<'_>, url: String, options: rquickjs::Opt<Object<'_>>| {
        let client = client_clone.clone();
        
        // âœ… æ­¥éª¤1ï¼šåˆ›å»º Promise å’Œ resolver
        let (promise, resolve, reject) = Promise::new(&ctx)?;
        
        // æå– options ä¸­çš„æ•°æ®ï¼ˆé¿å…ç”Ÿå‘½å‘¨æœŸé—®é¢˜ï¼‰
        let method = options.0.as_ref()
            .and_then(|o| o.get::<_, String>("method").ok())
            .unwrap_or_else(|| "GET".to_string());
        let body = options.0.as_ref()
            .and_then(|o| o.get::<_, String>("body").ok());
        let headers_map = extract_headers(&options.0);
        
        // âœ… æ­¥éª¤2ï¼šä½¿ç”¨ ctx.spawn åœ¨ JS runtime è°ƒåº¦å™¨å†…æ‰§è¡Œ
        // spawn è¦æ±‚ Future<Output=()>ï¼Œåœ¨å†…éƒ¨é€šè¿‡ resolve/reject å®Œæˆ Promise
        ctx.spawn(async move {
            match fetch_impl_pure(client, url, method, body, headers_map).await {
                Ok(response) => {
                    // âœ… åœ¨æŒé”çŠ¶æ€ä¸‹ resolve Promise
                    let _ = resolve.call::<_, ()>((response,));
                }
                Err(e) => {
                    // âœ… åœ¨æŒé”çŠ¶æ€ä¸‹ reject Promise
                    let _ = reject.call::<_, ()>((e.message,));
                }
            }
        });
        
        // âœ… æ­¥éª¤3ï¼šè¿”å› Promiseï¼ˆç«‹å³è¿”å›ï¼Œå¼‚æ­¥å®Œæˆå settleï¼‰
        Ok(promise)
    })?)?;
    
    Ok(())
}

/// æå– headersï¼ˆçº¯æ•°æ®ï¼Œæ— ç”Ÿå‘½å‘¨æœŸä¾èµ–ï¼‰
fn extract_headers(options: &Option<Object<'_>>) -> Vec<(String, String)> {
    let mut result = Vec::new();
    if let Some(opts) = options {
        if let Ok(headers) = opts.get::<_, Object>("headers") {
            // ç®€åŒ–å®ç°ï¼šéå†å¸¸è§ header
            for key in ["Authorization", "Content-Type", "Accept"] {
                if let Ok(val) = headers.get::<_, String>(key) {
                    result.push((key.to_string(), val));
                }
            }
        }
    }
    result
}

/// fetch çº¯å¼‚æ­¥å®ç°ï¼ˆæ—  JS ç”Ÿå‘½å‘¨æœŸä¾èµ–ï¼‰
async fn fetch_impl_pure(
    client: Arc<reqwest::Client>,
    url: String,
    method: String,
    body: Option<String>,
    headers: Vec<(String, String)>,
) -> Result<JsResponse, PluginError> {
    // ğŸ”’ å®‰å…¨æ£€æŸ¥
    validate_url(&url)?;
    
    // æ„å»ºè¯·æ±‚
    let mut request = match method.to_uppercase().as_str() {
        "GET" => client.get(&url),
        "POST" => client.post(&url),
        "PUT" => client.put(&url),
        "DELETE" => client.delete(&url),
        "PATCH" => client.patch(&url),
        "HEAD" => client.head(&url),
        _ => return Err(PluginError {
            error_type: PluginErrorType::NetworkError,
            message: format!("Unsupported HTTP method: {}", method),
            details: None,
        }),
    };
    
    // æ·»åŠ  headers
    for (key, value) in headers {
        if let Ok(header_name) = reqwest::header::HeaderName::from_bytes(key.as_bytes()) {
            request = request.header(header_name, value);
        }
    }
    
    // æ·»åŠ  body
    if let Some(b) = body {
        request = request.body(b);
    }
    
    // å‘é€è¯·æ±‚
    let response = request.send().await.map_err(|e| PluginError {
        error_type: PluginErrorType::NetworkError,
        message: format!("Network error: {}", e),
        details: None,
    })?;
    
    let status = response.status().as_u16();
    let status_text = response.status().canonical_reason()
        .unwrap_or("Unknown")
        .to_string();
    let ok = response.status().is_success();
    
    // è¯»å–å“åº”ä½“ï¼ˆå¸¦å¤§å°é™åˆ¶ï¼‰
    let bytes = response.bytes().await.map_err(|e| PluginError {
        error_type: PluginErrorType::NetworkError,
        message: format!("Failed to read response: {}", e),
        details: None,
    })?;
    
    if bytes.len() > MAX_RESPONSE_SIZE {
        return Err(PluginError {
            error_type: PluginErrorType::SandboxLimit,
            message: format!("Response too large: {} bytes (max: {})", bytes.len(), MAX_RESPONSE_SIZE),
            details: None,
        });
    }
    
    let body_text = String::from_utf8_lossy(&bytes).to_string();
    
    Ok(JsResponse { ok, status, status_text, body: body_text })
}

/// URL å®‰å…¨éªŒè¯
fn validate_url(url: &str) -> Result<(), PluginError> {
    // ä»…å…è®¸ HTTPSï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
    #[cfg(not(debug_assertions))]
    if !url.starts_with("https://") {
        return Err(PluginError {
            error_type: PluginErrorType::NetworkError,
            message: "Only HTTPS requests are allowed".to_string(),
            details: None,
        });
    }
    
    // ç¦æ­¢è®¿é—®å†…ç½‘åœ°å€
    let forbidden_patterns = ["localhost", "127.0.0.1", "0.0.0.0", "::1", "169.254.", "10.", "172.16.", "192.168."];
    for pattern in forbidden_patterns {
        if url.contains(pattern) {
            return Err(PluginError {
                error_type: PluginErrorType::NetworkError,
                message: "Access to internal networks is forbidden".to_string(),
                details: None,
            });
        }
    }
    
    Ok(())
}

/// JS Response å¯¹è±¡ï¼ˆæ¨¡æ‹Ÿ Web Fetch API Responseï¼‰
#[derive(Clone)]
#[rquickjs::class]
pub struct JsResponse {
    #[qjs(get)]
    pub ok: bool,
    #[qjs(get)]
    pub status: u16,
    #[qjs(get, rename = "statusText")]
    pub status_text: String,
    body: String,
}

#[rquickjs::methods]
impl JsResponse {
    /// è¿”å›å“åº”ä½“æ–‡æœ¬
    pub fn text(&self) -> String {
        self.body.clone()
    }
    
    /// è§£æ JSON å“åº”
    pub fn json(&self, ctx: Ctx<'_>) -> JsResult<Value<'_>> {
        ctx.json_parse(self.body.clone())
    }
}

// âœ… JsResponse ä½¿ç”¨ #[rquickjs::class] å®ï¼Œè‡ªåŠ¨å®ç° IntoJs
// æ— éœ€æ‰‹åŠ¨å®ç° JsLifetimeï¼ˆè¯¥ trait åœ¨ rquickjs 0.6.* ä¸­ä¸å­˜åœ¨ï¼‰
```

##### console API å®ç°

```rust
use tracing::{debug, info, warn, error};

/// æ³¨å…¥ console APIï¼ˆæ¡¥æ¥åˆ° Rust æ—¥å¿—ç³»ç»Ÿï¼‰
fn inject_console_api(ctx: &Ctx<'_>) -> JsResult<()> {
    let globals = ctx.globals();
    let console = Object::new(ctx.clone())?;
    
    // console.log
    console.set("log", Function::new(ctx.clone(), |args: rquickjs::Rest<Value>| {
        let msg = args_to_string(&args.0);
        info!(target: "plugin", "{}", msg);
    })?)?;
    
    // console.warn
    console.set("warn", Function::new(ctx.clone(), |args: rquickjs::Rest<Value>| {
        let msg = args_to_string(&args.0);
        warn!(target: "plugin", "{}", msg);
    })?)?;
    
    // console.error
    console.set("error", Function::new(ctx.clone(), |args: rquickjs::Rest<Value>| {
        let msg = args_to_string(&args.0);
        error!(target: "plugin", "{}", msg);
    })?)?;
    
    // console.debug
    console.set("debug", Function::new(ctx.clone(), |args: rquickjs::Rest<Value>| {
        let msg = args_to_string(&args.0);
        debug!(target: "plugin", "{}", msg);
    })?)?;
    
    globals.set("console", console)?;
    Ok(())
}

fn args_to_string(args: &[Value]) -> String {
    args.iter()
        .map(|v| format!("{:?}", v))  // ç®€åŒ–å®ç°
        .collect::<Vec<_>>()
        .join(" ")
}
```

##### æ’ä»¶åŠ è½½ä¸æ‰§è¡Œ

> **ä¿®æ­£è¦ç‚¹**ï¼šä½¿ç”¨ `Module::declare` + `.eval()` è·å–æ¨¡å—å¯¼å‡ºï¼›æ³¨å…¥å®Œæ•´ context å¯¹è±¡

```rust
use std::path::Path;
use std::sync::atomic::{AtomicBool, Ordering};
use tokio::fs;

/// æ’ä»¶æ‰§è¡Œå™¨
pub struct PluginExecutor {
    runtime: AsyncRuntime,
    context: AsyncContext,
    http_client: Arc<reqwest::Client>,
    config: PluginRuntimeConfig,
    cancel_flag: Arc<AtomicBool>,
    cache: Arc<BalanceCache>,
}

impl PluginExecutor {
    /// åˆ›å»ºæ–°çš„æ‰§è¡Œå™¨
    pub async fn new(
        config: PluginRuntimeConfig,
        cache: Arc<BalanceCache>,
    ) -> Result<Self, PluginError> {
        let http_client = Arc::new(
            reqwest::Client::builder()
                .timeout(std::time::Duration::from_millis(config.timeout_ms))
                .build()
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::NetworkError,
                    message: format!("Failed to create HTTP client: {}", e),
                    details: None,
                })?
        );
        
        let cancel_flag = Arc::new(AtomicBool::new(false));
        let runtime = create_sandbox_runtime(&config, cancel_flag.clone()).await
            .map_err(|e| PluginError {
                error_type: PluginErrorType::Unknown,
                message: format!("Failed to create runtime: {}", e),
                details: None,
            })?;
        let context = create_sandbox_context(&runtime, http_client.clone(), cache.clone()).await
            .map_err(|e| PluginError {
                error_type: PluginErrorType::Unknown,
                message: format!("Failed to create context: {}", e),
                details: None,
            })?;
        
        Ok(Self { runtime, context, http_client, config, cancel_flag, cache })
    }
    
    /// åŠ è½½å¹¶æ‰§è¡Œæ’ä»¶
    /// âœ… ä¿®æ­£ï¼šä½¿ç”¨ declare + eval æ¨¡å¼è·å–æ¨¡å—å¯¼å‡º
    pub async fn load_plugin(&self, plugin_path: &Path) -> Result<PluginMetadata, PluginError> {
        let source = fs::read_to_string(plugin_path).await
            .map_err(|e| PluginError {
                error_type: PluginErrorType::Unknown,
                message: format!("Failed to read plugin file: {}", e),
                details: None,
            })?;
        
        let module_name = plugin_path.file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("plugin")
            .to_string();
        
        rquickjs::async_with!(&self.context => |ctx| {
            // âœ… æ­¥éª¤1ï¼šå£°æ˜æ¨¡å—ï¼ˆä¸ç«‹å³æ‰§è¡Œï¼‰
            let module = Module::declare(ctx.clone(), module_name.clone(), source)
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::ParseError,
                    message: format!("Failed to parse module: {}", e),
                    details: None,
                })?;
            
            // âœ… æ­¥éª¤2ï¼šæ‰§è¡Œæ¨¡å—ï¼Œè¿”å› (Module<Evaluated>, Promise) å…ƒç»„
            let (evaluated_module, promise) = module.eval()
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::Unknown,
                    message: format!("Failed to evaluate module: {}", e),
                    details: None,
                })?;
            
            // âœ… ä½¿ç”¨ into_future().await ç­‰å¾…æ¨¡å—æ‰§è¡Œå®Œæˆï¼ˆé©±åŠ¨ job queue + futuresï¼‰
            promise.into_future::<()>().await
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::Unknown,
                    message: format!("Module execution failed: {}", e),
                    details: None,
                })?;
            
            // âœ… æ­¥éª¤3ï¼šä» evaluated module è·å–å‘½åç©ºé—´
            let namespace = evaluated_module.namespace()
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::Unknown,
                    message: format!("Failed to get module namespace: {}", e),
                    details: None,
                })?;
            
            // è·å– metadata å¯¼å‡º
            let metadata_val: Value = namespace.get("metadata")
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::ParseError,
                    message: format!("Plugin missing 'metadata' export: {}", e),
                    details: None,
                })?;
            
            // è§£æä¸º Rust ç»“æ„ä½“
            let json_str = ctx.json_stringify(metadata_val)
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::ParseError,
                    message: format!("Failed to stringify metadata: {}", e),
                    details: None,
                })?
                .unwrap_or_default();
            
            let metadata: PluginMetadata = serde_json::from_str(&json_str)
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::ParseError,
                    message: format!("Failed to parse metadata: {}", e),
                    details: None,
                })?;
            
            // å°† queryBalance å‡½æ•°æŒ‚è½½åˆ°å…¨å±€ï¼ˆä¾›åç»­è°ƒç”¨ï¼‰
            let query_fn: Function = namespace.get("queryBalance")
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::ParseError,
                    message: format!("Plugin missing 'queryBalance' export: {}", e),
                    details: None,
                })?;
            ctx.globals().set("__pluginQueryBalance__", query_fn)
                .map_err(|e| PluginError {
                    error_type: PluginErrorType::Unknown,
                    message: format!("Failed to register queryBalance: {}", e),
                    details: None,
                })?;
            
            Ok(metadata)
        }).await
    }
    
    /// æ‰§è¡ŒæŸ¥è¯¢ä½™é¢
    /// âœ… ä½¿ç”¨ watchdog + interrupt handler å®ç°å¯æŠ¢å è¶…æ—¶
    pub async fn query_balance(
        &self,
        plugin_id: &str,
        plugin_name: &str,
        config: serde_json::Value,
    ) -> BalanceResult {
        // é‡ç½®å–æ¶ˆæ ‡å¿—
        self.cancel_flag.store(false, Ordering::Relaxed);
        
        // âœ… å¯åŠ¨ watchdogï¼ˆç‹¬ç«‹ä»»åŠ¡ï¼Œå³ä½¿ JS é˜»å¡ä¹Ÿèƒ½è§¦å‘è¶…æ—¶ï¼‰
        let watchdog_handle = start_watchdog(
            self.cancel_flag.clone(),
            self.config.timeout_ms,
        );
        
        // æ‰§è¡Œæ’ä»¶
        let result = rquickjs::async_with!(&self.context => |ctx| {
            // è°ƒç”¨æ’ä»¶çš„ queryBalance å‡½æ•°
            let query_fn: Function = ctx.globals().get("__pluginQueryBalance__")?;
            
            // æ„å»ºå®Œæ•´çš„ context å¯¹è±¡
            let js_context = self.build_plugin_context(&ctx)?;
            
            // å°† config è½¬ä¸º JS å¯¹è±¡
            let js_config = ctx.json_parse(config.to_string())?;
            
            // è°ƒç”¨å‡½æ•°ï¼Œè·å– Promise
            let promise: Promise = query_fn.call((js_config, js_context))?;
            
            // âœ… ä½¿ç”¨ into_future().await ç­‰å¾… Promise å®Œæˆ
            let result_val: Value = promise.into_future().await?;
            
            // è§£æç»“æœä¸º PluginBalanceResponse
            let json_str = ctx.json_stringify(result_val)?
                .unwrap_or_default();
            // âœ… ä½¿ç”¨ map_err å°† serde_json::Error è½¬æ¢ä¸º rquickjs::Error
            let response: PluginBalanceResponse = serde_json::from_str(&json_str)
                .map_err(|e| rquickjs::Error::FromJs {
                    from: "JSON",
                    to: "PluginBalanceResponse",
                    message: Some(e.to_string()),
                })?;
            
            Ok::<_, rquickjs::Error>(response)
        }).await;
        
        // âœ… åœæ­¢ watchdogï¼ˆé¿å…æ™šåˆ°çš„ watchdog æ±¡æŸ“åç»­æ‰§è¡Œï¼‰
        watchdog_handle.abort();
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ watchdog è§¦å‘çš„è¶…æ—¶ï¼ˆcancel_flag è¢«ç½®ä½ï¼‰
        let was_cancelled = self.cancel_flag.load(Ordering::Relaxed);
        
        // å¤„ç†ç»“æœ
        match result {
            Ok(response) if !was_cancelled => BalanceResult {
                provider: plugin_id.to_string(),
                provider_name: plugin_name.to_string(),
                last_updated: chrono::Utc::now(),
                status: BalanceStatus::Success,
                error_message: None,
                balance: response.balance,
                currency: response.currency,
                quota: response.quota,
                used_quota: response.used_quota,
                expires_at: response.expires_at,
                raw_data: response.raw_data,
            },
            // âœ… å¦‚æœ cancel_flag è¢«ç½®ä½ï¼Œå³ä½¿è¿”å› Ok ä¹Ÿè§†ä¸ºè¶…æ—¶
            Ok(_) | Err(_) if was_cancelled => BalanceResult {
                provider: plugin_id.to_string(),
                provider_name: plugin_name.to_string(),
                last_updated: chrono::Utc::now(),
                status: BalanceStatus::Timeout,
                error_message: Some("Plugin execution timeout (interrupted)".to_string()),
                balance: 0.0,
                currency: String::new(),
                quota: None,
                used_quota: None,
                expires_at: None,
                raw_data: None,
            },
            Err(e) => BalanceResult {
                provider: plugin_id.to_string(),
                provider_name: plugin_name.to_string(),
                last_updated: chrono::Utc::now(),
                status: BalanceStatus::Error,
                error_message: Some(format!("Plugin error: {}", e)),
                balance: 0.0,
                currency: String::new(),
                quota: None,
                used_quota: None,
                expires_at: None,
                raw_data: None,
            },
        }
    }
    
    /// æ„å»ºæ’ä»¶æ‰§è¡Œä¸Šä¸‹æ–‡
    fn build_plugin_context<'js>(&self, ctx: &Ctx<'js>) -> JsResult<Object<'js>> {
        let js_context = Object::new(ctx.clone())?;
        
        // timeout
        js_context.set("timeout", self.config.timeout_ms)?;
        
        // log å‡½æ•°
        js_context.set("log", Function::new(ctx.clone(), |level: String, message: String| {
            match level.as_str() {
                "debug" => tracing::debug!(target: "plugin", "{}", message),
                "info" => tracing::info!(target: "plugin", "{}", message),
                "warn" => tracing::warn!(target: "plugin", "{}", message),
                "error" => tracing::error!(target: "plugin", "{}", message),
                _ => tracing::info!(target: "plugin", "{}", message),
            }
        })?)?;
        
        // TODO: cache å’Œ storage API éœ€è¦æ›´å¤æ‚çš„å®ç°
        // è¿™é‡Œé¢„ç•™æ¥å£ï¼Œæš‚è¿”å›ç©ºå¯¹è±¡
        js_context.set("cache", Object::new(ctx.clone())?)?;
        js_context.set("storage", Object::new(ctx.clone())?)?;
        
        Ok(js_context)
    }
}
```

##### å¹¶å‘æ‰§è¡Œå¤šä¸ªæ’ä»¶

```rust
use futures::stream::{self, StreamExt};
use std::collections::HashMap;

/// æ’ä»¶ç®¡ç†å™¨
pub struct PluginManager {
    executors: HashMap<String, PluginExecutor>,
    config: PluginRuntimeConfig,
    rate_limiter: Arc<governor::RateLimiter</* ... */>>,
}

impl PluginManager {
    /// å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰ä¸­è½¬ç«™ä½™é¢
    /// âœ… ä¿®æ­£ï¼šquery_balance è¿”å› BalanceResultï¼Œæ— éœ€ match Result
    pub async fn query_all_balances(
        &self,
        plugin_configs: HashMap<String, (String, serde_json::Value)>,  // (plugin_name, config)
    ) -> Vec<BalanceResult> {
        let max_concurrent = self.config.max_concurrent_requests;
        
        stream::iter(plugin_configs)
            .map(|(plugin_id, (plugin_name, config))| {
                let executor = self.executors.get(&plugin_id);
                async move {
                    if let Some(exec) = executor {
                        // é™æµæ£€æŸ¥
                        self.rate_limiter.until_ready().await;
                        
                        // âœ… query_balance ç›´æ¥è¿”å› BalanceResult
                        exec.query_balance(&plugin_id, &plugin_name, config).await
                    } else {
                        BalanceResult {
                            provider: plugin_id.clone(),
                            provider_name: plugin_name,
                            balance: 0.0,
                            currency: String::new(),
                            quota: None,
                            used_quota: None,
                            expires_at: None,
                            last_updated: chrono::Utc::now(),
                            status: BalanceStatus::Error,
                            error_message: Some("Plugin not found".to_string()),
                            raw_data: None,
                        }
                    }
                }
            })
            .buffer_unordered(max_concurrent)  // æ§åˆ¶å¹¶å‘åº¦
            .collect()
            .await
    }
}
```

##### é™æµå™¨é…ç½®

```rust
use governor::{Quota, RateLimiter};
use std::num::NonZeroU32;

/// åˆ›å»ºé™æµå™¨
pub fn create_rate_limiter(
    requests_per_second: u32,
    burst_size: u32,
) -> RateLimiter</* ... */> {
    let quota = Quota::per_second(NonZeroU32::new(requests_per_second).unwrap())
        .allow_burst(NonZeroU32::new(burst_size).unwrap());
    
    RateLimiter::direct(quota)
}
```

##### ç¼“å­˜å±‚å®ç°

```rust
use moka::future::Cache;
use std::time::Duration;

/// ä½™é¢ç¼“å­˜
pub struct BalanceCache {
    cache: Cache<String, BalanceResult>,
}

impl BalanceCache {
    pub fn new(ttl_seconds: u64, max_capacity: u64) -> Self {
        let cache = Cache::builder()
            .time_to_live(Duration::from_secs(ttl_seconds))
            .max_capacity(max_capacity)
            .build();
        
        Self { cache }
    }
    
    pub async fn get(&self, plugin_id: &str) -> Option<BalanceResult> {
        self.cache.get(plugin_id).await
    }
    
    pub async fn set(&self, plugin_id: &str, result: BalanceResult) {
        self.cache.insert(plugin_id.to_string(), result).await;
    }
    
    pub async fn invalidate(&self, plugin_id: &str) {
        self.cache.invalidate(plugin_id).await;
    }
    
    pub async fn invalidate_all(&self) {
        self.cache.invalidate_all();
    }
}
```

##### ç›®å½•ç»“æ„

```
src/
â”œâ”€â”€ plugin/
â”‚   â”œâ”€â”€ mod.rs              # æ¨¡å—å…¥å£
â”‚   â”œâ”€â”€ executor.rs         # PluginExecutor å®ç°
â”‚   â”œâ”€â”€ manager.rs          # PluginManager å®ç°
â”‚   â”œâ”€â”€ sandbox/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ runtime.rs      # æ²™ç›’ Runtime åˆ›å»º
â”‚   â”‚   â”œâ”€â”€ fetch.rs        # fetch API å®ç°
â”‚   â”‚   â”œâ”€â”€ console.rs      # console API å®ç°
â”‚   â”‚   â””â”€â”€ globals.rs      # å…¨å±€å¯¹è±¡æ³¨å…¥/ç§»é™¤
â”‚   â”œâ”€â”€ cache.rs            # BalanceCache
â”‚   â”œâ”€â”€ rate_limit.rs       # é™æµå™¨
â”‚   â””â”€â”€ types.rs            # ç±»å‹å®šä¹‰
â””â”€â”€ main.rs
```

### 9.9 æ’ä»¶ API è§„èŒƒ (Plugin API Specification)

#### 9.9.1 æ’ä»¶æ–‡ä»¶ç»“æ„

```
~/.claude/plugins/balance/
â”œâ”€â”€ balance_openai.js      # OpenAI ä¸­è½¬ç«™æ’ä»¶
â”œâ”€â”€ balance_anthropic.js   # Anthropic ä¸­è½¬ç«™æ’ä»¶
â”œâ”€â”€ balance_deepseek.js    # DeepSeek ä¸­è½¬ç«™æ’ä»¶
â””â”€â”€ balance_xxx.js         # å…¶ä»–ä¸­è½¬ç«™æ’ä»¶
```

#### 9.9.2 æ’ä»¶å…ƒæ•°æ®è§„èŒƒ

æ¯ä¸ªæ’ä»¶å¿…é¡»å¯¼å‡ºä»¥ä¸‹å…ƒæ•°æ®ï¼š

```javascript
export const metadata = {
  // å¿…å¡«å­—æ®µ
  id: "balance_openai",           // å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆä¸æ–‡ä»¶åä¸€è‡´ï¼‰
  name: "OpenAI Balance",         // æ˜¾ç¤ºåç§°
  version: "1.0.0",               // è¯­ä¹‰åŒ–ç‰ˆæœ¬å·
  apiVersion: "1.0",              // å…¼å®¹çš„ API ç‰ˆæœ¬
  
  // å¯é€‰å­—æ®µ
  author: "Author Name",          // ä½œè€…
  description: "æŸ¥è¯¢ OpenAI ä¸­è½¬ç«™ä½™é¢",  // æè¿°
  homepage: "https://...",        // ä¸»é¡µé“¾æ¥
  icon: "openai.png",             // å›¾æ ‡æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
  
  // é…ç½®é¡¹å£°æ˜
  configSchema: {
    apiKey: { type: "string", required: true, secret: true },
    baseUrl: { type: "string", required: false, default: "https://api.openai.com" }
  }
};
```

#### 9.9.3 å¿…é¡»å®ç°çš„å‡½æ•°

> **ä¸ Rust å®ç°å¯¹é½**ï¼šä½¿ç”¨ `response.json()` æ–¹æ³•ï¼›ä½¿ç”¨æ³¨å…¥çš„ `PluginError` ç±»

```javascript
/**
 * æŸ¥è¯¢ä½™é¢ï¼ˆå¿…é¡»å®ç°ï¼‰
 * @param {Object} config - ç”¨æˆ·é…ç½®çš„ API Key ç­‰ä¿¡æ¯
 * @param {Object} context - æ‰§è¡Œä¸Šä¸‹æ–‡
 *   - timeout: number (æ¯«ç§’)
 *   - log: (level, message) => void
 *   - cache: { get, set }
 *   - storage: { get, set }
 * @returns {Promise<BalanceResponse>} - ä½™é¢æŸ¥è¯¢ç»“æœ
 */
export async function queryBalance(config, context) {
  // ä½¿ç”¨ context.log è®°å½•æ—¥å¿—
  context.log('info', `Querying balance for ${config.baseUrl}`);
  
  const response = await fetch(`${config.baseUrl}/v1/dashboard/billing/credit_grants`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${config.apiKey}`,
      'Content-Type': 'application/json'
    }
  });
  
  if (!response.ok) {
    // ä½¿ç”¨æ³¨å…¥çš„ PluginError ç±»ï¼ˆç»§æ‰¿è‡ª Errorï¼‰
    throw new PluginError(
      ErrorTypes.PROVIDER_ERROR,
      `HTTP ${response.status}: ${response.statusText}`
    );
  }
  
  // ä½¿ç”¨ .json() æ–¹æ³•è§£æå“åº”ï¼ˆRust ä¾§å·²å®ç°ï¼‰
  const data = await response.json();
  
  // âœ… è¿”å›å€¼å­—æ®µä¸ Rust PluginBalanceResponse å¯¹åº”
  return {
    balance: data.total_available ?? 0,
    currency: "USD",
    quota: data.total_granted,
    usedQuota: data.total_used,
    expiresAt: data.grants?.[0]?.expires_at,
    rawData: data
  };
}

/**
 * éªŒè¯é…ç½®ï¼ˆå¯é€‰å®ç°ï¼‰
 * @param {Object} config - ç”¨æˆ·é…ç½®
 * @returns {Promise<ValidationResult>} - éªŒè¯ç»“æœ
 */
export async function validateConfig(config) {
  if (!config.apiKey || !config.apiKey.startsWith('sk-')) {
    return { valid: false, message: "API Key æ ¼å¼ä¸æ­£ç¡®" };
  }
  return { valid: true };
}

/**
 * å¥åº·æ£€æŸ¥ï¼ˆå¯é€‰å®ç°ï¼‰
 * @returns {Promise<boolean>} - ä¸­è½¬ç«™æ˜¯å¦å¯ç”¨
 */
export async function healthCheck(config) {
  // è½»é‡çº§çš„å¯ç”¨æ€§æ£€æŸ¥
  return true;
}
```

#### 9.9.4 æ’ä»¶ä¸Šä¸‹æ–‡å¯¹è±¡ (Context)

```typescript
interface PluginContext {
  // è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  timeout: number;
  
  // æ—¥å¿—å‡½æ•°
  log: (level: 'debug' | 'info' | 'warn' | 'error', message: string) => void;
  
  // ç¼“å­˜ APIï¼ˆä»…è¯»å–ï¼‰
  cache: {
    get: (key: string) => Promise<any>;
    set: (key: string, value: any, ttl?: number) => Promise<void>;
  };
  
  // æ’ä»¶å­˜å‚¨ï¼ˆæŒä¹…åŒ–é…ç½®ï¼‰
  storage: {
    get: (key: string) => Promise<any>;
    set: (key: string, value: any) => Promise<void>;
  };
}
```

#### 9.9.5 é”™è¯¯å¤„ç†è§„èŒƒ

```javascript
// æ ‡å‡†é”™è¯¯ç±»å‹
const ErrorTypes = {
  NETWORK_ERROR: 'NETWORK_ERROR',      // ç½‘ç»œè¿æ¥å¤±è´¥
  AUTH_ERROR: 'AUTH_ERROR',            // è®¤è¯å¤±è´¥ï¼ˆAPI Key æ— æ•ˆï¼‰
  RATE_LIMIT: 'RATE_LIMIT',            // è¢«é™æµ
  TIMEOUT: 'TIMEOUT',                  // è¶…æ—¶
  PARSE_ERROR: 'PARSE_ERROR',          // å“åº”è§£æå¤±è´¥
  PROVIDER_ERROR: 'PROVIDER_ERROR',    // ä¸­è½¬ç«™è¿”å›é”™è¯¯
  UNKNOWN: 'UNKNOWN'                   // æœªçŸ¥é”™è¯¯
};

// æŠ›å‡ºæ ‡å‡†é”™è¯¯
throw new PluginError(ErrorTypes.AUTH_ERROR, "API Key å·²è¿‡æœŸ");
```

### 9.10 æ’ä»¶é…ç½®ç®¡ç† (PluginConfig)

| åŠŸèƒ½ç‚¹ | æè¿° | çŠ¶æ€ |
|--------|------|------|
| API Key å®‰å…¨å­˜å‚¨ | åŠ å¯†å­˜å‚¨æ•æ„Ÿé…ç½® | [ ] |
| é…ç½® UI è‡ªåŠ¨ç”Ÿæˆ | æ ¹æ® configSchema ç”Ÿæˆè¡¨å• | [ ] |
| é…ç½®éªŒè¯ | ä¿å­˜å‰è°ƒç”¨ validateConfig | [ ] |
| å¯¼å…¥/å¯¼å‡º | é…ç½®çš„å¤‡ä»½å’Œæ¢å¤ | [ ] |

### 9.11 åŠŸèƒ½ç»Ÿè®¡æ›´æ–°

| ç±»åˆ« | æ–°å¢æ•°é‡ |
|------|----------|
| æ’ä»¶ç³»ç»Ÿæ¨¡å— | 8 |
| å®‰å…¨é™åˆ¶è§„åˆ™ | 8 (é»‘åå•) |
| æ’ä»¶ API æ¥å£ | 3 (å¿…é€‰1 + å¯é€‰2) |
| é…ç½®é¡¹ | 6+ |

